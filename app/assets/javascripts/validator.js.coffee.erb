validators = {}
<% [Ticket, Workspace].each do |klass| %>

validators[<%= klass.name.inspect.html_safe %>] = <%= JsValidator.build_hash(klass).to_json %>;

<% end %>

test_functions =
  presence_validator: (value, options) ->
    [I18n.t("activerecord.errors.presence")] if value != "" || value != null || value != undefined
  presence: (element, options) ->
          options.message if /^\s*$/.test(element.val() || '')
  acceptance: (element, options) ->
    switch element.attr('type')
      when 'checkbox'
        unless element.attr('checked')
          return options.message
      when 'text'
        if element.val() != (options.accept?.toString() || '1')
          return options.message

  format: (element, options) ->
    message = @presence(element, options)
    if message
      return if options.allow_blank == true
      return message
    
    return options.message if options.with and !options.with.test(element.val())
    return options.message if options.without and options.without.test(element.val())

  numericality: (element, options) ->
    unless /^-?(?:\d+|\d{1,3}(?:,\d{3})+)(?:\.\d*)?$/.test(element.val())
      return options.messages.numericality

    if options.only_integer and !/^[+-]?\d+$/.test(element.val())
      return options.messages.only_integer

    CHECKS =
      greater_than: '>'
      greater_than_or_equal_to: '>='
      equal_to: '=='
      less_than: '<'
      less_than_or_equal_to: '<='

    # options[check] may be 0 so we must check for undefined
    for check, operator of CHECKS when options[check]?
      fn = new Function("return #{element.val()} #{operator} #{options[check]}")
      return options.messages[check] unless fn()

    if options.odd and !(parseInt(element.val(), 10) % 2)
      return options.messages.odd

    if options.even and (parseInt(element.val(), 10) % 2)
      return options.messages.even

  length: (element, options) ->
    tokenizer = options.js_tokenizer || "split('')"
    tokenized_length = new Function('element', "return (element.val().#{tokenizer} || '').length")(element)
    CHECKS =
      is: '=='
      minimum: '>='
      maximum: '<='
    blankOptions = {}
    blankOptions.message = if options.is
      options.messages.is
    else if options.minimum
      options.messages.minimum

    message = @presence(element, blankOptions)
    if message
      return if options.allow_blank == true
      return message

    for check, operator of CHECKS when options[check]
      fn = new Function("return #{tokenized_length} #{operator} #{options[check]}")
      return options.messages[check] unless fn()

  exclusion: (element, options) ->
    message = @presence(element, options)
    if message
      return if options.allow_blank == true
      return message

    if options.in
      return options.message if element.val() in (o.toString() for o in options.in)

    if options.range
      lower = options.range[0]
      upper = options.range[1]
      return options.message if element.val() >= lower and element.val() <= upper

  inclusion: (element, options) ->
    message = @presence(element, options)
    if message
      return if options.allow_blank == true
      return message

    if options.in
      return if element.val() in (o.toString() for o in options.in)
      return options.message

    if options.range
      lower = options.range[0]
      upper = options.range[1]
      return if element.val() >= lower and element.val() <= upper
      return options.message

  confirmation: (element, options) ->
    if element.val() != jQuery("##{element.attr('id')}_confirmation").val()
      return options.message
class Validator

  constructor: (attributes, klass) ->
    @errors = []
    @attributes = attributes
    @validator = validators[klass]
    @validate()
  
  valid: -> @errors.length == 0
  validate: ->
    @errors = {}
    _.each @validator, (field, validators) =>
      @errors[field] = []
      _.each validators, (validator) =>
        @errors[field].push test_functions[validator.type](@attributes[field], validator.options)
        
      
