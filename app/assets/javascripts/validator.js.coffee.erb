validators = {}
<% [Ticket, Workspace].each do |klass| %>

validators[<%= klass.name.inspect.html_safe %>] = <%= JsValidator.build_hash(klass).to_json %>;

<% end %>

test_functions =
  presence_validator: (element, options) -> I18n.t("errors.messages.blank") if /^\s*$/.test(element || '')
  acceptance_validator: (element, options) -> I18n.t("errors.messages.accepted") if /^\s*$/.test(element || '')
  format_validator: (element, options) ->
    message = @presence(element, options)
    if message
      return if options.allow_blank == true
      return message
    
    return options.message if options.with and !options.with.test(element.val())
    return options.message if options.without and options.without.test(element.val())

  numericality_validator: (element, options) ->
    unless /^-?(?:\d+|\d{1,3}(?:,\d{3})+)(?:\.\d*)?$/.test(element.val())
      return options.messages.numericality

    if options.only_integer and !/^[+-]?\d+$/.test(element.val())
      return options.messages.only_integer

    CHECKS =
      greater_than: '>'
      greater_than_or_equal_to: '>='
      equal_to: '=='
      less_than: '<'
      less_than_or_equal_to: '<='

    # options[check] may be 0 so we must check for undefined
    for check, operator of CHECKS when options[check]?
      fn = new Function("return #{element.val()} #{operator} #{options[check]}")
      return options.messages[check] unless fn()

    if options.odd and !(parseInt(element.val(), 10) % 2)
      return options.messages.odd

    if options.even and (parseInt(element.val(), 10) % 2)
      return options.messages.even

  length_validator: (element, options) ->
    tokenizer = options.js_tokenizer || "split('')"
    tokenized_length = new Function('element', "return (element.val().#{tokenizer} || '').length")(element)
    CHECKS =
      is: '=='
      minimum: '>='
      maximum: '<='
    blankOptions = {}
    blankOptions.message = if options.is
      options.messages.is
    else if options.minimum
      options.messages.minimum

    message = @presence(element, blankOptions)
    if message
      return if options.allow_blank == true
      return message

    for check, operator of CHECKS when options[check]
      fn = new Function("return #{tokenized_length} #{operator} #{options[check]}")
      return options.messages[check] unless fn()

  exclusion_validator: (element, options) ->
    message = @presence(element, options)
    if message
      return if options.allow_blank == true
      return message

    if options.in
      return options.message if element.val() in (o.toString() for o in options.in)

    if options.range
      lower = options.range[0]
      upper = options.range[1]
      return options.message if element.val() >= lower and element.val() <= upper

  inclusion_validator: (element, options) ->
    message = @presence(element, options)
    if message
      return if options.allow_blank == true
      return message

    if options.in
      return if element.val() in (o.toString() for o in options.in)
      return options.message

    if options.range
      lower = options.range[0]
      upper = options.range[1]
      return if element.val() >= lower and element.val() <= upper
      return options.message

  confirmation_validator: (element, options) ->
    if element.val() != jQuery("##{element.attr('id')}_confirmation").val()
      return options.message

class Validator

  constructor: (attributes, klass) ->
    @errors = []
    @attributes = attributes
    @validator = validators[klass]
    @validate()
  
  valid: -> @errors.length == 0
  validate: ->
    @errors = {}
    _.each @validator, (field, validators) =>
      @errors[field] = []
      _.each validators, (validator) =>
        @errors[field].push test_functions[validator.type](@attributes[field], validator.options)
        
      
